---
title: 스프링 프레임워크 핵심 기술
tags: 
 - Spring
key: 3
---

## IoC(Inversion of Control)

IoC는 의존 관계 주입(Dependency Injection)이라고도 하며, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법

``` java
private BookRepository bookRepository = new BookRepository(); // X

@Autowired                             // 객체를 주입 받아 사용
private BookRepository bookRepository; // O
```

IoC에 어노테이션을 스캔하여 Bean을 등록하고 컨테이너에서 가져와 자동으로 주입

@Service, @Repository, @Autowired... 등

IoC의 핵심적인 클래스 **BeanFactory **



#### Bean

* 스프링 IoC 컨테이너가 관리하는 객체 @Service @Repository 등 
* 싱글톤으로 관리하고 싶을 때 IoC 컨테이너를 사용하면 굉장히 편리
* 장점
  * 의존성 관리
  * 스코프
    * 싱글톤: 하나
    * 프로토타입: 매번 다른 객체
  * 라이프사이클 인터페이스

#### ApplicationContext

* BeanFactory
* 메시지 소스 처리기능 (i18n)
* 이벤트 발행 기능
* 리소스 로딩 기능



### ApplicationContext와 다양한 빈 설정 방법

##### application.xml 설정방법

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">

    <!-- 직접 빈 설정 -->
	<bean id="bookService"
		class="me.yoon.springapplicationcontext.BookService">
		<property name="bookRepository" ref="bookRepository" />
	</bean>
	<bean id="bookRepository"
		class="me.yoon.springapplicationcontext.BookRepository">
	</bean>

    <!-- 자동 스캔 하여 빈 설정 -->
	<context:component-scan base-package="me.yoon.springapplicationcontext" />
</beans>
```

``` java
@Service
public class BookService {
	@Autowired
	BookRepository bookRepository;
}

@Repository
public class BookRepository {
}
```

``` java
ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
```

##### java code configure 방식

``` java
@Configuration
public class ApplicationConfig {
	@Bean
	public BookRepository bookRepository() {
		return new BookRepository();
	}
	
	@Bean
	public BookService bookService() {
        BookService bookService = new BookService();
        bookService.setBookRepository(bookRepository());
		return bookService;
        
        //return new BookService();  @Autowired 
	}
}
```

or

``` java
@Configuration
@ComponentScan(basePackageClasses = Application.class)
public class ApplicationConfig {
}
```

``` java
@Service
public class BookService {
	@Autowired
	BookRepository bookRepository;
}

@Repository
public class BookRepository {
}
```



``` java
ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);
```

##### 스프링 부트 방식

``` java
@SpringBootApplication
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
```



### @Autowired

필요한 의존 객체의 "타입"에 해당하는 빈을 찾아 주입한다.

빈으로 등록되어 있어야 한다. @Service @Repository @Component ...

@Autowired required 기본값은 true (못찾으면 애플리케이션 구동 실패)

##### @Autowired 사용할 수 있는 위치

###### 생성자 (스프링 4.3 부터는 생략 가능)

``` java
@Autowired
public BookService(BookRepository bookRepository) {
	this.bookRepository = bookRepository;
}
```

###### 세터

레포지토리에 @Repository 빈으로 등록이 안되어 있다면 BookService 인스턴스는 만들 수 있지만 Autowired가 붙어있기 때문에 오류가 난다. (autowired 때문에 빈을 주입하려는 시도는 하기 때문)

```java
@Autowired(required = false) // required 옵션 default true
public void setBookRepository(BookRepository bookRepository) {
	this.bookRepository = bookRepository;
}
```

###### 필드

``` java
@Autowired
BookRepository bookRepository;
```



##### 경우의 수

* 해당 타입의 빈이 없는 경우
* 해당 타입의 빈이 한 개인 경우
* 해당 타입의 빈이 여러 개인 경우
  * 빈 이름으로 시도
    * 같은 이름의 빈 찾으면 해당 빈사용
    * 같은 이름 못 찾으면 실패

같은 타입의 빈이 여러개 일때 (interface 구현체 여러개)

* @Primary를 붙여서 주입하고 싶은 객체 설정

  ``` java
  @Repository @Primary
  public class FirstRepository implements BookRepository{
  }
  ```

* 해당 타입의 빈 모두 주입받기 List 형태

  ```java
  @Autowired
  List<BookRepository> bookRepositories;
  ```

* @Qualifier(빈 이름으로 주입)

  ``` java
  @Service
  public class BookService {
  	@Autowired @Qualifier("firstBookRepository")
  	BookRepository bookRepository;
  }
  ```

##### 동작원리

빈 라이프 사이클

BeanFactory에 등록된

BeanPostProcessor에 의해 동작

AutowiredAnnotationBeanProcessor가 찾는다.



### @Component와 컴포넌트 스캔

##### 컴포넌트 스캔 - 컴포넌트 클래스를 Bean으로 등록하는 과정

@Component

* @Repository, @Service, @Controller, @Configuration

@SpringBootApplication이 붙은 Appication 클래스에서 컴포넌트 스캔이 시작된다. 포함된 패키지와 이하 패키지도 모두 스캔을 한다. 다른 패키지는 스캔이 되지 않는다.
모든 @이 붙은 클래스를 빈으로 등록하는 것이 아니고 filter로 거르고 필요한 것만 빈으로 등록
초기에 싱글톤으로 생성하므로 등록할 Bean이 많을 경우 초기 구동시간이 오래 걸릴 수 있다.

컴포넌트 스캔 외에 직접 빈을 등록하는 방법이 있으나 많은 빈을 직접 등록하기엔 불편하므로 컴포넌트 스캔을 사용하자.

### 빈의 스코프

싱글톤 - 애플리케이션 전반에 걸쳐 해당 빈에 인스턴스가 오직 한개

프로토타입: 매번 새로운 객체(인스턴스)를 만들어서 사용해야 하는 스코프

``` java
@Component @Scope("prototype")
public class Proto {
}
```

##### 프로토타입의 빈이 싱글톤 빈을 참조하면?

-> 프로토타입의 빈은 매번 새로워도 싱글톤 스코프는 매번 같은 인스턴트가 들어오기 때문에 아무 문제가 없다.

##### 싱글톤타입의 빈이 프로토타입 빈을 참조하면?

-> 프로토타입의 빈이 바뀌지 않고 한개만 참조한다.

###### 해결방법1

``` java
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
```

프로토를 상속받은 프록시를 거쳐서 프로토타입을 사용해야한다. 프록시 인스턴스가 빈으로 등록이 된다. 타입은 프로토타입이므로 주입이 가능하다.

###### 해결방법2

``` java
@Component
public class Single {
	@Autowired
	private ObjectProvider<Proto> proto;
	
	public Proto getProto() {
		return proto.getIfAvailable();
	}
}
```

코드에 스프링 관련 코드가 들어가므로 차라리 **방법1**로 선언하는 방법이 낫다.
프로토타입은 그렇게 많이 사용되지는 않는다.

싱글톤 객체 사용시 주의할 점.

* 프로퍼티가 공유하므로 다른 쓰레드에서 서로 사용될 수 있으므로 쓰레드 세이프한 방법으로 코딩을 해야한다
* 모든 싱글톤 빈은 ApplicationContext 초기 구동시 인스턴스가 생성된다.



### Environment 1부. 프로파일

환경에 따라 빈을 다르게 하고 싶은 경우

프로파일과 프로퍼티를 다루는 인터페이스

##### 프로파일 

* 빈들의 그룹
* Environment의 역할은 활성화할 프로파일 확인 및 설정



##### 프로파일 유즈케이스

* 테스트 환경에서는 A라는 빈을 사용하고, 배포 환경에서는 B라는 빈을 쓰고 싶다

``` 
Application extends EnvironmentCapable
getEnvironment()
```

##### 프로파일 정의하기

클래스에 정의 @Configuration @Profile("test") @Component @Profile("test")

메소드에 정의 @Bean @Profile("test")

@Profile("!prod") prod가 아닌 경우

```java
@Configuration
@Profile("test")
public class TestConfiguration {
	@Bean
    public BookRepository bookRepository() {
        return new TestBookRepository();
    }
}
```

test라는 프로파일로 실행을 해야만 실행이 된다.

##### 

##### 프로파일 설정하기

IDE에서 active profiles -> test

VM options -> -Dspring.profiles.active="test"

### Environment 2부. 프로퍼티

##### 프로퍼티

* 다양한 방법으로 정의할 수 있는 설정값

* Environment의 역할은 프로퍼티 소스 설정 및 프로퍼티 값 가져오는 것



JVM 시스템 프로퍼티 (-Dkey="value")



##### application에서 설정

@PropertySource("classpath:/app.properties")



### MessageSource

메세지를 국제화 기능을 제공하는 인터페이스



```java
@Autowired
MessageSource messageSource;
```

messages.properties

``` properties
greeting=Hello {0}
```

messages_ko_kr.properties

```properties
greeting=안녕, {0}
```

스프링 부트를 사용하면 설정없이 messages로 시작하는 properties를 읽어와 사용 가능



리로딩 기능이 있는 메세지 소스 사용

```java
@Bean
public MessageSource messageSource(){
	var messageSource = new ReloadableResourceBundleMessageSource();
	messageSource.setBasename("classpath:/messages")
	messageSource.setDefaultEncoding("UTF-8");
	return messageSource;
}
```

messages 프로퍼티 값을 변경하고 빌드를 하면 메세지가 리로딩 된다.



### ApplicationEventPublisher

이벤트 프로그래밍에 필요한 인터페이스 제공, 옵저버 패턴 구현체.

Application extends ApplicationEventPublisher

* publishEvent(Application event)



#### 이벤트 만들기

스프링 4.2 부터 ApplicationEvent 상속 받지 않아도 된다.  스프링이 추구하는 방향. 스프링 소스코드가 자기 코드에 노출되지 않는 것이 POJO 기반의 프로그래밍 

테스트하기 편하고, 코드 유지보수가 쉬움



##### MyEvent.class 이벤트

```java
public class MyEvent {
	private int data;
	private Object source;

	public MyEvent(Object source, int data) {
		this.data = data;
		this.source = source;
	}
	
	public int getData() {
		return data;
	}
	
	public Object getSource() {
		return source;
	}
}
```

##### MyEventHandler.class   이벤트 처리

``` java
@Component
public class MyEventHandler {
	@EventListener
    // @Order(Ordered.HIGHEST_PRECEDENCE + '숫자')
    // @Async	비동기실행 순서 보장 x application에 @EnableAsync
	private void myHandler(MyEvent event) {
		System.out.println("이벤트 "  +  event.getData());
	}
}
```

##### 이벤트 사용

```java
@Component
public class AppRunner implements ApplicationRunner{
	@Autowired
	ApplicationEventPublisher publishEvent;
	
	@Override
	public void run(ApplicationArguments args) throws Exception {
		publishEvent.publishEvent(new MyEvent(this, 100));
	}	
}
```

##### 스프링이 제공하는 기본 이벤트

ContextRefreshedEvent - ApplicationContext 초기화 or 리프레시
ContextStartEvent - ApplicationContext start() 하여 라이프사이클 빈들이 시작신호 받은 시점
ContextClosedEvent - ApplicationContext stop() 하여 라이프사이클 빈들이 정지신호 받은 시점 
ContextStoppedEvent - ApplicationContext close() 하여 싱글톤 빈 소멸되는 시점 받은 시점 



### ResourceLoader

리소스를 읽어오는 기능을 제공하는 인터페이스

리소스 읽어오기

* 파일 시스템에서 읽어오기
* 클래스패스에서 읽어오기
* URL로 읽어오기
* 상대/절대 경로로 읽어오기

---
title: effective java 3/E - 12장. 직렬화
tags: 
 - Java
key: 17

---



# 12장 직렬화

##### 12장에서 배울 내용

* 객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘이다.
* 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역 직렬화할 수 있다.
* 직렬화가 품고 있는 위험과 그 위험을 최소화하는 방법에 집중한다.



___



## 아이템 85: 자바 직렬화의 대안을 찾으라

자바에 직렬화가 처음 도입된 후 어렵지 않게 분산 객체를 만들 수 있다는 것은 매력적이었지만, 보이지 않는 생성자, API와 구현 사이의 모호해진 경계, 잠재적인 정확성 문제, 성능 보안, 유지보수성 등 문제에 대한 대가가 크다.

##### 직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.

* ObjectInputStream의 readObject 메서드를 호출하면 객체 그래프가 역직렬화되기 때문이다.
* readObject 메서드는 클래스패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있다.
* 바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행할 수 있으며, 이는 곧 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다.

##### 자바의 표준 라이브러리나 아파치 커먼즈 컬렉션 같은 서드파티는 물론 애플리케이션 자신의 클래스들도 공격 범위에 속한다.

* 모든 직렬화 가능 클래스들을 공격에 대비하도록 작성하여도, 애플리케이션은 취약할 수 있다.

##### 역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 폭탄이라고 한다.

###### 예제 코드) 역직렬화 폭탄 - 이 스트림의 역 직렬화는 영원히 계속된다.

~~~java
public class DeserializationBomb {
    public static void main(String[] args) throws Exception {
        System.out.println(bomb().length);
        deserialize(bomb());
    }

    static byte[] bomb() {
        Set<Object> root = new HashSet<>();
        Set<Object> s1 = root;
        Set<Object> s2 = new HashSet<>();
        for (int i = 0; i < 100; i++) {
            Set<Object> t1 = new HashSet<>();
            Set<Object> t2 = new HashSet<>();
            t1.add("foo"); // t1을 t2와 다르게 만든다.
            s1.add(t1);
            s1.add(t2);
            s2.add(t1);
            s2.add(t2);
            s1 = t1;
            s2 = t2;
        }
        return serialize(root); // 이 메서드는 effectivejava.chapter12.Util 클래스에 정의되어 있다.
    }
}
~~~

1. 이 객체 그래프는 201개의 HashSet 인스턴스로 구성되며, 각각은 3개 이하의 객체 참조를 갖는다.
2. 스트림의 전체 크기는  5744 바이트이지만, 역직렬화는 영원히 끝나지 않을 것이다.
3. 문제는 HashSet 인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산해야 한다는 데 있다.
4. 루트 HashSet에 담긴 두 원소는 각각 다른 HashSet 2개씩을 원소로 갖는 HashSet이다.
5. 반복문에 의해 이 구조가 깊이 100 단계 까지 만들어진다.
6. 이 HashSet을 역직렬화하려면 hashCode를 2¹⁰⁰ 번 넘게 호출해야 한다.
7. 역직렬화가 계속되는 것도 문제지만, 무언가 잘못되었다는 신호조차 주지 않으며 단 몇 개의 객체만 생성해도 스택 깊이 제한에 걸린다.

##### 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.

* 작성하는 새로운 시스템에서 자바 직렬화를 써야할 이유는 전혀 없다.

* 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있다.

  이 방식들은 자바 직렬화의 위험을 회피하면서 다양한 플랫폼 지원, 우수한 성능, 풍부한 지원 도구, 활발한 커뮤니티와 전문가 집단 등 수많은 이점까지 제공한다.

##### 데이터 표현의 선두주자는 JSON과 프로토콜 버퍼다.

* JSON은 브라우저와 서버의 통신용으로 설계되었다.
* 프로토콜 버퍼는 서버 사이에 데이터를 교환하고 저장하기 위해 설계했다.

##### JSON과 프로토콜 버퍼의 차이

* JSON은 텍스트 기반으로 사람이 읽을 수 있고, 데이터를 표현하는 데만 쓰인다.
* 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 높으며, 문서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다.
* JSON은 텍스트 기반 표현에 아주 효과적이고, 프로토콜 버퍼는 사람이 읽을 수 있는 텍스트 표현(pbtxt)도 지원한다.

##### 레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책

* 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.

* 자바의 공식 보안 코딩 지침에서는 "신뢰할 수 없는 데이터의 역직렬화는 본질적으로 위험하므로 절대로 피해야 한다"라고 조언한다.

* 직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 역직렬화 필터링(java.io.ObjectInputFilter)을 사용하자.

  * 객체 역직렬화 필터링은 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다.

  * 클래스 단위로, 특정 클래스를 받아들이거나 거부할 수 있다.

  * '기본 수용' 모드에서 블랙리스트에 기록된 잠재적 위험한 클래스를 거부한다.

  * '기본 거부' 모드에서 화이트리스트에 기록된 안전한 클래스들만 수용한다.

  * ##### 화이트 방식을 추천한다.

##### 직렬화는 여전히 자바 생태계 곳곳에 쓰이고 있다.

* 시간과 노력을 들여서라도 JSON이나 프로토콜 버퍼 같은 대안으로 마이그레이션하는 것을 심각하게 고민해보길 바란다.
* 하지만 현실적인 이유로 직렬화 가능 클래스를 작성하거나 유지보수해야 할 수 있기에 직렬화 가능 클래스를 올바르고 안전하고 효율적으로 작성하려면 상당한 주의가 필요하다.



##### 핵심 정리

> 직렬화는 위험하니 피해야 한다. 시스템을 밑바닥부터 설계한다면 JSON이나 프로토콜 버퍼 같은 대안을 사용하자.  신뢰할 수 없는 데이터는 역직렬화하지 말자. 꼭 해야 한다면 객체 역직렬화 필터링을 사용하되, 이마저도 모든 공격을 막아줄 수는 없음을 기억하자. 클래스가 직렬화를 지원하도록 만들지 말고, 꼭 그렇게 만들어야 한다면 정말 신경써서 작성해야 한다.



___



## 아이템 86: Serializable을 구현할지는 신중히 결정하라

어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 Serializable을 구현하면 된다. 직렬화를 지원하기란 짧게 보면 쉬워보이지만, 길게 보면 아주 값비싼 일이다.

##### Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.

* 클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩(직렬화된 형태)도 하나의 공개 API가 된다.
* 이 클래스가 널리 퍼진다면 그 직렬화 형태도 영원히 지원해야 하는 것이다.
* 커스텀 직렬화 형태를 설계하지 않고 기본 방식을 사용한다면 직렬화 형태는 최소 적용 당시의 내부 구현 방식에 영원히 묶여버린다.
* 기본 직렬화 형태에서는 클래스의 private과 package-private 인스턴스 필드들마저 API로 공개되는 꼴이 된다.
* 뒤늦게 수정하기도 어렵기 때문에, 직렬화 가능 클래스를 만들고자 한다면 고품질의 직렬화 형태도 주의해서 함께 설계해야 한다.

##### 직렬화가 클래스 개선을 방해하는 간단한 예

* ##### 대표적으로 스트림 고유 식별자, 직렬 버전 UID(serial version UID)를 들 수 있다.

  * 모든 직렬화 클래스는 고유 식별 번호를 부여받는다. **serialVersionUID**
  * 이 번호를 명시하지 않으면 시스템이 런타임에 암호 해시 함수를 적용해 자동으로 클래스 안에 생성해 넣는다.
  * 이 값을 생성하는 데는 클래스 이름, 구현한 인터페이스들, 컴파일러가 자동으로 생성해 넣은 것을 포함한 대부분의 클래스 멤버들이 고려된다.
  * 나중에 내부 수정을 한다면 UID 값도 변해 호환성이 깨져버려 InvalidClassException이 발생할 것이다.

* ##### 버그와 보안 구멍이 생길 위험이 높아진다.

  * 객체는 생성자를 사용해 만드는게 기본이다.
  * 직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법인 것이다.
  * 역직렬화는 일반 생성자의 문제가 그대로 적용되는 '숨은 생성자' 다.
  * 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다.

* ##### 해당 클래스의 신버전을 릴리스 할 때 테스트할 것이 늘어난 다는 것이다.

  * 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화 할 수 있는지, 그리고 그 반대도 가능한지 검사해야 한다.
  * 양방향 직렬화/역직렬화가 모두 성공하고, 원래의 객체를 충실히 복제해내는지 반드시 확인해야 한다.
  * 클래스를 처음 제작할 때 커스텀 직렬화 형태를 잘 설계했다면 테스트 부담은 줄일 수 있다.

##### Serializable 구현 여부는 가볍게 결정할 사안이 아니다.

* 객체를 전송하거나 저장할 때 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스라면 선택의 여지가 없다.
* Serializable을 반드시 구현해야 하는 다른 클래스의 컴포넌트로 쓰일 클래스도 마찬가지다.
* 역사적으로 BigInteger와 Instant 같은 값 클래스와 컬렉션 클래스들은 Serializable을 구현하고, 스레드 풀처럼 동작하는 객체를 표현하는 클래스들은 대부분 구현하지 않았다.

##### 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서는 안 된다.

* 그런 클래스를 확장하거나 그런 인터페이스를 구현하는 이에게 커다란 부담을 지우게 된다.
* 예외로 Serializable을 구현한 클래스만 지원하는 프레임워크를 사용하는 상황이라면 다른 방도가 없을 것이다.

##### 작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능 할 때 주의할 점

* 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야 한다. finalize 메서드를 자신이 재정의하면서 final로 선언한다.

* 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 readObjectNoData 메서드를 반드시 추가해야 한다.

  ##### 상태가 있고, 확장 가능하고, 직렬화 가능한 클래스용 readObjectNoData 메서드

  ~~~java
  private void readObjectNoData() throw InvalidObjectException {
      throw new InvalidObjectException("스트림 데이터가 필요합니다.")
  }
  ~~~

  

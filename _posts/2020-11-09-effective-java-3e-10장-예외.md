---
title: effective java 3/E - 10장. 예외
tags: 
 - Java
key: 15
---



# 10장 예외

##### 10장에서 배울 내용

* 예외를 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만, 잘못사용하면 반대의 효과가 난다.
* 예외로 효과적으로 활용하는 지침을 다룬다



___



## 아이템 69: 예외는 진짜 예외 상황에만 사용하라

##### 예외를 완전히 잘못 사용한 예 - 따라하지 말 것!

~~~java
try {
    int i = 0;
    while(true) {
        range[i++].climb();
    }
} catch(ArrayIndexOutOfBoundsException e) {
}
~~~

* 이 코드는 전혀 직관적이지 않다는 사실 하나로 이렇게 작성하면 안 되는 이유로 충분하다.

* 무한루프를 돌다가 배열 원소의 끝에 도달해 ArrayIndexOutOfBoundsException이 발생하면 끝을 낸다.

* 다음과 같이 표준적인 관용구대로 작성했다면 모든 자바 프로그래머가 곧바로 이해했을 것이다.

  ~~~java
  for(Mountain m : range)
      m.climb();
  ~~~

##### 예외를 써서 루프를 종료한 이유는 무엇일까?

* 잘못된 추론을 근거로 성능을 높여보려 한 것이다.
* JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료한다.
* 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것이다.

하지만 세 가지 면에서 잘못된 추론이다.

1. 예외는 예외 상황에서 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다.(최적화에 별로 신경 쓰지 않았을 가능성이 크다.)
2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.

##### 예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리는데서 끝나지 않고 제대로 동작하지 않을 수 있다.

* 반복문 안에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 할 것이다.
* 반복문의 몸체에서 호출한 메서드가 내부에서 관련 없는 배열을 사용하다가 ArrayIndexOutOfBoundsException을 발생시켰다고 해보자.
* 표준 관용구 였다면 이 버그는 예외를 잡지 않고 해당 스레드를 즉각 종료 시킬 것이다.
* 반면 예외를 사용한 반복문은 버그 때문에 발생한 엉뚱한 예외를 정상적인 반복문 종료 상황으로 오해하고 넘어간다.

##### 예외는 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.

* 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라.
* 반면 과하게 영리한 기법에 숨겨진 미묘한 버그의 폐혜와 어려워진 유지보수 문제는 계속이어 질 것이다.

##### 잘설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

* 특정 상태에서만 호출할 수 있는 '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 한다.
* Iterator 인터페이스의 next와 hasNext가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다.

~~~java
for(Iterator<Foo> i = collection.iterator(); i.hasNext();) {
    Foo foo = i.next();
    ...
}
~~~

##### 상태 검사 메서드 대신 빈 옵셔널, null 같은 특수한 값을 반환하는 방법도 있다. 

상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기 쉽다. 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다.

##### 핵심 정리

> 예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안 되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안 된다.



___



## 아이템 70: 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

자바는 문제 상황을 알리는 타입으로 검사 예외, 런타임 예외, 에러 세 가지를 제공하는데, 언제 무엇을 사용해야 하는지 헷갈려 하는 프로그래머들이 종종 있다.

##### 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.

* 이것이 검사와 비검사 예외를 구분하는 기본 규칙이다.
* 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.
* 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다.
* API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에 회복해내라고 요구한 것이다.
* 사용자는 예외를 잡기만 하고 별다른 조치를 취하지 않을 수 도 있지만, 이는 보통 좋지 않은 생각이다.

##### 비검사 throwable은 두 가지, 바로 런타임 예외와 에러이다.

* 둘 다 동작 측면에서는 다르지 않다. 
* 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로는 잡지 말아야 한다.
* 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.
* 이런 throwable을 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다.

##### 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.

* 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.
* 전제조건 위배란 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했다는 뜻이다.
* 배열의 인덱스는 0에서 사이즈 - 1 사이여야 한다.
  ArrayIndexOutOfBoundsException이 발생했다는 것은 이 전제조건이 지켜지지 않았다는 것이다.

##### 에러는 보통 JVM 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.

* Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하길 바란다.

* ##### 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.

* Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다.

##### Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들 수도 있다.

* throwable을 직접 다루지는 않지만, 일반적인 검사 예외(RuntimeException을 상속하지 않은)처럼 다룬다.
* 하지만 이로울 수 없으니 절대로 사용하지 말자!

##### 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다.

* 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.
* 예를들어, 쇼핑몰에서 물건을 구입하려는 데 카드 잔고가 부족하여 검사 예외가 발생했다면, 이 예외는 잔고가 얼마나 부족한지를 알려주는 접근자 메서드를 제공해야 한다.



##### 핵심 정리

> 복구할 수 있는 상황이라면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 확실하지 않다면 비검사 예외를 던지자. 검사 예외도 아니고 런타임 예외도 아닌  throwable은 정의하지도 말자. 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.



___



## 아이템 71: 필요 없는 검사 예외 사용은 피하라

검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높이게끔 해준다. 물론 과하게 사용하면 오히려 쓰기 불편한 API 가 될 수 있다.

API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우라면 검사 예외를 사용하는 부담은 받아들일 수 있지만 그 외에는 비검사 예외를 사용하는 것이 좋다.

##### 검사 예외와 비검사 예외 중 어느 것을 선택해야 할까?

~~~java
} catch (TheCheckedException e) {
    throw new AssertionError(); // 일어날 수 없다!
}

} catch(TheCheckedException e) {
    e.printStackTrace(); 
    System.exit(1);
}
~~~

* 위 두가지 검사 예외는 불필요한 예외로 더 나은 방법이 없다면 비검사 예외를 선택해야 한다.

##### 검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 특히 크다.

* 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 상황이라면 catch 문 하나를 추가하면 된다.
* 하지만 검사 예외가 단 하나뿐이라면 오직 그 예외 때문에 API 사용자는 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.

##### 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.

* 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.
* 이 방식의 단점이라면 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.
* 반면, 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.

##### 또 다른 방법으로, 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.

~~~java
// 검사 예외를 던지는 메서드 - 리팩터링 전
try {
    obj.action(args);
} catch(TheCheckedException e) {
    ...// 예외 상황에 대처한다.
}
~~~

~~~java
// 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후
if(obj.actionPermitted(args)){
    obj.action(args);
} else {
    ...// 예외 상황에 대처한다.
}
~~~

* 이 리팩터링은 모든 방식에 사용할 수 없지만 적용할 수 있다면 쓰기 편한 API를 제공할 수 있다.



##### 핵심 정리

> 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다. API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.



___



## 아이템 72: 표준 예외를 사용하라

자바 라이브러리는 대부분 API에서 쓰기에 충분한 수의 예외를 제공한다.

##### 표준 예외를 재사용하면 얻는 게 많다.

* 그중 최고는 API가 다른 사람이 익히고 사용하기 쉬워진다.
* 이미 익숙한 규약을 그대로 따르기 때문이다.
* 낯선 예외를 사용하지 않게 되어 읽기 쉽게 된다는 장점도 있다.
* 예외 클래스 수가 적을 수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.

##### 예외 종류

* ##### 가장 많이 사용되는 예외 IllegalArgumentException이다.

  * 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외이다.

* ##### IllegalStateException도 자주 재사용된다.

  * 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던진다.

* ##### NullPointerException 

  * null 값을 허용하지 않는 메서드에 null을 건넬 때 던진다.

* ##### IndexOutOfBoundsException

  * 시퀀스의 허용 범위를 넘으면 던진다.

* ##### ConcurrentModificationException

  * 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 던진다. 

* ##### UnsupportedOperationException

  * 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.

* ##### Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.

  * 이 예외들은 다른 예외들의 상위 클래이므로, 안정적으로 테스트할 수 없다.

##### IllegalArgumentException과 IllegalStateException 중 선택하기 어려울 때

* 인수 값이 무엇이었든 어차피 실패할 때는 IllegalStateException
* 아니라면 IllegalArgumentException



___



## 아이템 73: 추상화 수준에 맞는 예외를 던지라

수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스러울 것이다. 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다. **상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.**

##### 예외 번역

~~~java
try {
   ... // 저수준 추상화를 이용한다.
} catch(LowerLevelException e) {
   // 추상화 수준에 맞게 번역한다.
   throw new HigherLevelException(...);
}
~~~

##### AbstractSequentialList 에서 수행하는 예외 번역의 예

~~~java
/**
 * 이 리스트 안의 지정한 위치의 원소를 반환한다.
 * @throws IndexOutOfBoundsException index 범위가 밖이라면,
 *         즉 ({@code index < 0 || index >= size()})이면 발생한다.
 */
public E get(int index) {
  ListIterator<E> i = listIterator(index);
  try {
      return i.next();
  } catch (NoSuchElementException e) {
      throw new IndexOutOfBoundsException("인덱스: " + index);
  }
}
~~~

##### 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는 게 좋다.

* 예외 연쇄란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.

##### 예외 연쇄

~~~java
try {
    ...// 저수준 추상화를 이용한다.
} catch(LowerLevelException cause) {
    // 저수준 예외를 고수준 예외에 실어 보낸다.
    throw new HigherLevelException(cause);
}
~~~

##### 예외 연쇄용 생성자

~~~java
class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
~~~

* 대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.
* 그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 '원인'을 직접 못박을 수 있다.
* 예외 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며, 원인과 고수준 예외의 스택 추적 정보를 잘 통합해준다.

##### 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 안된다.

* 가능하다면 저수준 메서드가 반드시 성공하도록하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.
* 때론 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다.
* 차선책으로 아래 계층에서 예외를 피할 수 없다면 적절한 로깅을 활용하여 기록해두라.



##### 핵심 정리

> 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.



___



## 아이템 74: 메서드가 던지는 모든 예외를 문서화하라

각 메서드가 더지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.

##### 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.

* 공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 삼가자.
* 극단적인 예로 메서드가 Exception이나 Throwable을 던진다고 선언해서 안된다.
* main 메서드는 오직 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다.

##### 비검사 예외도 검사 예외처럼 정성껏 문서화해두면 좋다.

* 비검사 예외는 일반벅으로 프로그래밍 오류를 뜻하는데, 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.
* 잘 정비된 비검사 예외 문서는 사실상 그 메서드를 성공적으로 수행하기 위한 전제조건이 된다.
* public 메서드라면 필요한 전제조건을 문서화해야 하며, 그 수단으로 가장 좋은 것이 바로 비검사 예외들을 문서화하는 것이다.

##### 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.

* 검사냐 비검사냐에 따라 API 사용자가 해야 할 일이 달라지므로 이 둘을 확실히 구분해주는 게 좋다.
* 자바독 유틸리티는 메서드 선언의 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.

##### 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다.

* NullPointerException이 가장 흔한 사례다.



##### 핵심 정리

> 메서드가 던질 가능성이 있는 모든 예외를 문서화하라. 검사 예외든 비검사 예외든, 추상 메서드든 구체 메서드든 모두 마찬가지다. 문서화에는 자바독의 @throws 태그를 사용하면 된다. 검사 예외만 메서드 선언의 @throws 문에 일일히 선언하고, 비검사 예외는 메서드 선언에 기입하지 말자. 발생 가능한 예외를 문서로 남기지 않으면 다른 사람이 그 클래스나 인터페이스를 효과적으로 사용하기 어렵거나 심지어 불가능할 수도 있다.



___



## 아이템 75: 예외의 상세 메시지에 실패 관련 정보를 담으라

예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보를 자동으로 출력한다. 스택 추적은 예외 객체의 toString 메서드를 호출해 얻는 문자열로, 보통은 예외의 클래스 이름 뒤에 상세 메시지가 붙는 형태다.

##### 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.

* IndexOutOfBoundsException의 상세 메시지는 범위의 최솟값과 최댓값, 그리고 그 범위를 벗어났다는 인덱스의 값을 담아야 한다.

> 보안과 관련한 정보는 주의해서 다뤄야 한다. 문제를 진단하고 해결하는 과정에서 스택 추적 정보를 많은 사람이 볼 수 있으므로 상세 메시지에 비밀번호나 암호 키 같은 정보까지 담아서는 안 된다.

* 관련한 데이터를 모두 담아야 하지만 장황할 필요는 없다.
* 문제를 분석하는 사람은 스택 추적뿐 아니라 관련 문서와 소스코드를 함께 살펴본다.
* 스택 추적에는 예외가 발생한 파일 이름과 줄번호는 물론 스택에서 호출한 다른 메서드들의 파일 이름이 줄번호까지 정확하게 기록되어 있는 게 보통이다.

##### 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안 된다.

* 최종 사용자에게는 친절한 안내 메시지를 보여줘야 하는 반면, 예외 메시지는 가독성보다는 담긴 내용이 훨씬 중요하다.
* 예외 메시지의 주 소비층은 문제를 분석해야 할 프로그래머와 SRE 엔지니어이기 때문이다.
* 실패를 적절히 포착하려면 필요한 정보를 예외 생성자에서 모두 받아서 상세 메시지까지 미리 생성해놓는 방법도 괜찮다.

##### 예외는 실패와 관련한 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.

* 포착한 실패 정보는 예외 상황을 복구하는 데 유용할 수 있으므로 접근자 메서드는 비검사 예외보다는 검사 예외에서 더 빛을 발한다.



___



## 아이템 76: 가능한 한 실패 원자적으로 만들라

호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다. 이러한 상태를 **실패 원자적** 이라고 한다.

##### 메서드를 실패 원자적으로 만드는 방법은 다양하다.

* 가장 간단한 방법은 불변 객체로 설계하는 것이다.

* 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 작업 수행에 앞서 매개변수의 유효성을 검사하는 것이다.

  객체 내부 상태를 변경하기 전에 잠재정 예외의 가능성 대부분을 걸러낼 수 있는 방법이다.

  #####  Stack의 pop 메서드

  ~~~java
  public Object pop() {
      if(size == 0)
          throw new EmptyStackException();
      Object result = elements[--size];
      elements[size] = null;
      return result;
  }
  ~~~

  실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법도 있다.

  계산을 수행해보기 전에는 인수의 유효성을 검사해볼 수 없을 때 앞서의 방식에 덧붙여 쓸 수 있는 기법이다.

  ex) TreeMap은 원소들을 어떤 기준으로 정렬한다. 원소를 추가하려면 TreeMap의 기준에 따라 비교할 수 있는 타입이어야 한다. 엉뚱한 타입의 원소를 추가하려들면 해당 원소의 위치를 찾는 과정에서 ClassCastException을 던진다.

* 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것이다.

  데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식이다.

  ex) 정렬 메서드에서는 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨 담아 비교한다.

* 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법이다.

  주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰인다. 자주 쓰이지는 않는다.

##### 실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할 수 있는 것은 아니다.

* 실패 원자적으로 만들 수 있더라도 항상 그리해야 하는 것은 아니다.

  실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 있기 때문이다.

* 메서드 명세에 기술한 예외라면 설혹 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙이다.



___



## 아이템 77: 예외를 무시하지 말라

API 설계자가 메서드 선언에 예외를 명시하는 까닭은, 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다.

##### catch 블록을 비우면 예외가 무시된다.

~~~java
try {
   ...
} catch(SomeException e) {
}
~~~

* 예외는 문제 상황에 잘 대처하기 위해 존재하는데 catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
* 운이 좋아 별 탈이 없을 수도 있지만, 끔찍한 참사로 이어질 수 있으니 무시하지 말자.

##### 예외를 무시해야 할 때도 있다.

* FileInputStream 을 닫을 때 파일의 상태를 변경하지 않았으니 복구 할 것이 없으며, 남은 작업을 중단할 이유도 없다.

* ##### 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔 놓도록 하자.

  ~~~java
  Future<Integer> f = exec.submit(planarMap::chromaticNumber);
  int numColors = 4;
  try {
      numColors = f.get(1L, TimeUnit.SECONDS);
  } catch (TimeoutException | ExecutionException ignored) {
      // 기본값을 사용한다.
  }
  ~~~



##### 이번 절의 내용은 검사와 비검사 예외에 똑같이 적용된다.

* 예측할 수 있는 예외 상황이든 프로그래밍 오류든, 빈 catch 블록으로 못 본 척 지나치면 그 프로그램은 오류를 내재한 채 동작하게 된다.
* 그러다 어느 순간 문제의 원인과 아무 상관없는 곳에서 갑자기 죽어버릴 수도 있다.
* 예외를 적절히 처리하면 오류를 완전히 피할 수도 있다.



___

10장 예외 끝...
